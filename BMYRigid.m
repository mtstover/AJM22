/* Magma routine associated with the paper "Rigid surfaces arbitrarily close to the Bogomolov-Miyaoka-Yau line" by Matthew Stover and Giancarlo Urzua. We refer to this paper below as [SU]. This program can be run at any terminal running Magma by entering "magma BMYRigid.m". */

/* Definition of the Deligne-Mostow lattice in terms of the generators and relators given in Appendix A of [SU]. */

G<x,y> := Group<x,y | x^3, y^3, (y*x^-1*y)^12, ((y*x^-1*y)^2,(y*x^-1)^2)>;

printf "\nOur Deligne-Mostow lattice is the group G with generators x and y having presentation:\n\n%o\n\n", G;

/* Give the user the opportunity to check that this presentation matches the other presentation from Appendix A of [SU]. */

G2<b,u,v> := Group<b,u,v | b*v=v*b, b*u*b=u*b*u, u*v*u*v=v*u*v*u, (b*u*v)^3, b^3, u^3, v^6>;

printf "Check whether G is the same as the group given by the other presentation? (y/n)\n";

read ans0;

if ans0 eq "y" then
  printf "\nOther presentation is %o\n\n", G2;
  printf "Are G and G2 isomorphic: %o\n\n", SearchForIsomorphism(G, G2, 5);
else
  printf "\n";
end if;

/* Auxiliary elements. The cusp subgroup of G is generated by r and s (that is, the unique conjugacy class of cusp subgroups has a representative with these generators). */

s := y*x^-1;

r := (y*x^-1*y)^2;

t := s^2;

i1 := t*x;

/* List of all representatives for all conjugacy classes of finite order elements of G. This was obtained from the paper "A minimal volume arithmetic cusped complex hyperbolic orbifold" by T. Zhao. */

AllTors := [* t^-1*i1, (t^-1*i1)^2, s^-1*i1, (s^-1*i1)^2, r, r^2, r^3, r^4, r^5, r^-1*s, (r^-1*s)^2, i1, i1^2, i1^3, i1^4, i1^5, i1^6, i1^7, i1^8, i1^9, i1^10, i1^11, (t^-1*i1)*r, (t^-1*i1)*r^2, (t^-1*i1)*r^3, (t^-1*i1)*r^4, (t^-1*i1)*r^5, (t^-1*i1)^2*r, (t^-1*i1)^2*r^2, (t^-1*i1)^2*r^3, (t^-1*i1)^2*r^4, (t^-1*i1)^2*r^5, (i1*t^-1)*(s^-1*r), (i1*t^-1)*(s^-1*r)^2, (i1*t^-1)^2*(s^-1*r), (i1*t^-1)^2*(s^-1*r)^2, (s^-1*r)*(i1*t^-1), (s^-1*r)*(i1*t^-1)^2, (s^-1*r)^2*(i1*t^-1),(s^-1*r)^2*(i1*t^-1)^2, (i1*t^-1)*(s^-1*r)*(i1*t^-1), (i1*t^-1)*(s^-1*r)^2*(i1*t^-1), (i1*t^-1)^2*(s^-1*r)*(i1*t^-1), (i1*t^-1)^2*(s^-1*r)^2*(i1*t^-1), (i1*t^-1)*(s^-1*r)*(i1*t^-1)^2, (i1*t^-1)*(s^-1*r)^2*(i1*t^-1)^2, (i1*t^-1)^2*(s^-1*r)*(i1*t^-1)^2, (i1*t^-1)^2*(s^-1*r)^2*(i1*t^-1)^2, (s^-1*r)*(i1*t^-1)^2*(s^-1*r), (s^-1*r)^2*(i1*t^-1)*(s^-1*r)^2, (i1*t^-1)*(s^-1*r)^2*(i1*t^-1)*(s^-1*r)^2 *];

/* Definition of the lattice Gamma_1 from [SU]. */

Gam1<h1, h2, h3, h4> := Rewrite(G, LowIndexNormalSubgroups(G, 72)[14]`Group);

printf "The group we want to study is:\n\n%o\n\n", Gam1;

/* Though it is clear from the above definition, we check that Gam1 is normal in G and that is has the correct index. */

printf "Check whether Gam1 is a torsion-free subgroup of index 72? (y/n)\n";

read ans1;

if ans1 eq "y" then
  printf "\nChecking that Gam1 is normal in G: %o\n\n", IsNormal(G, Gam1);
  printf "The index of Gam1 in G is: %o\n\n", Index(G, Gam1);
/* We now check that Gam1 is torsion-free. Since it is normal in G, it suffices to check that it contains to element of the list AllTors. */
  IsTf := true;

  for a in AllTors do
    if a in Gam1 then
    IsTf := false;
  break a;
  end if;
  end for;

  printf "Checking that Gam1 is torsion-free: %o\n\n", IsTf;
else
  printf "\n";
end if;

/* The more geometrically natural generators that are in tune with the description of the associated ball quotient as having smooth toroidal compactification isomorphic to the blowup of an abelian surface. */

k1 := (s^-1, r^-1); k2 := (r, s^-1);
z1 := (k1, k2);
g1 := k1*k2^-1;
g2 := g1*k1^-1*z1*z1;
g3 := x^-1*g1*x;
g4 := x^-1*g2*x;
g5 := x*g1*x^-1;
g6 := x*g2*x^-1;
g7 := g1^-1*y*g1*y^-1*g1;
g8 := g1^-1*y*g2*y^-1*g1;
w1 := (g1, g2);
w2 := (g3, g4);
w3 := (g5, g6);
w4 := (g7, g8);

/* We give the user the opportunity to see each of these elements as words in the Magma-generated generators h1,...,h4. */

printf "See g1,...,g8 and w1,...,w4 as words in h1,...,h4? (y/n)\n";

read ans2;

if ans2 eq "y" then
  printf "As words in h1,..., h4, some critical elements of Gam1 for us are:\n\n g1 = %o\n\n g2 = %o\n\n g3 = %o\n\n g4 = %o\n\n g5 = %o\n\n g6 = %o\n\n g7 = %o\n\n g8 = %o\n\n w1 = %o w2 = %o\n\n w3 = %o\n\n w4 = %o\n\n", Gam1!g1, Gam1!g2, Gam1!g3, Gam1!g4, Gam1!g5, Gam1!g6, Gam1!g7, Gam1!g8, Gam1!w1, Gam1!w2, Gam1!w3, Gam1!w4;
else
  printf "\n";
end if;

/* Give the user the opportunity to check cusp data for Gam1. */

printf "Check number of cusps for Gam1? (y/n)\n";

read ans3;

/* We count cusps using the quotient group F = G/Gam1. The number of cusps is equal to the index in F of the image of the cusp subgroup <r,s> of G. */

F, Fh := G/Gam1;

FP, FPh := PermutationGroup(F);

Fr := FPh(Fh(r));

Fs := FPh(Fh(s));

FB := sub<FP | Fr, Fs>;

if ans3 eq "y" then
  printf "\nThe number of cusps of the ball quotient associated with Gam1 is: %o\n\n", Index(FP, FB);
else
  printf "\n";
end if;


/* The last point in checking that Gam1 is the lattice associated with Hirzebruch's ball quotient, we much check that its cusps subgroups are cusp subgroups associated with a smooth toroidal compactification. Note that since Gam1 is normal in G, it suffices to check one cusp. We take an abstract presentation for the cusp group, map it to FB, and present the kernel. */

B<R,S> := Group<R,S | R^6, (R^-1*S)^3, (R, S^2)>;

Bh := hom<B -> FP | R->Fr, S->Fs>;

BK<b1,b2> := Rewrite(B, Kernel(Bh));

Heisenberg<c1,c2,c3> := Group<c1,c2,c3 | (c1,c2)*c3^-1, (c1,c3), (c2,c3)>;

printf "See abstract presentation, in generators R,S for the cusp subgroup of G, for one (hence any) cusp subgroup of Gam1? (y/n)\n";

read ans4;

if ans4 eq "y" then
  BKH := SearchForIsomorphism(BK, Heisenberg, 5);
  printf "\n%o\n\n", BK;
  printf "Checking that BK is isomorphic to the standard integer Heisenberg group with presentation:\n\n%o\n\n", Heisenberg;
  printf "Check that they are isomorphic: %o\n\n", BKH;
else
  printf "\n";
end if;

/* Note that the pairs <g_{2j-1}, g_{2j}> are defined by G-conjugates of g1 and g2 for every j. The conjugating elements are x, x^-1, and y^-1*g1. To show that these are indeed representatives for the four distinct cusp subgroups of Gam1, it suffices to show that the images in F of x, x^-1, and y^-1*g1 represent the nontrivial coset representatives of FB (the image of <r,s> in F) in F. */

AllFour := true;

if (FPh(Fh(x))*FPh(Fh(x^-1))^-1 in FB) or (FPh(Fh(x))*FPh(Fh(y^-1*g1))^-1 in FB) or (FPh(Fh(x^-1))*FPh(Fh(y^-1*g1))^-1 in FB) then
  AllFour := false;
end if;

printf "Check that the groups <g_{2j-1}, g_{2j}> generate the four conjugacy classes of cusp subgroups of Gam1? (y/n)\n";

read ans5;

if ans5 eq "y" then
  printf "\n%o\n\n", AllFour;
else
  printf "\n";
end if;

/* We lastly check that g1,...,g4 generates all of Gam1 */

printf "Check that Gam1 is generated by g1,...,g4? (y/n)\n";

read ans6;

if ans6 eq "y" then
  printf "\n%o\n\n", Index(Gam1, sub<Gam1 | g1, g2, g3, g4>) eq 1;
else
  printf "\n";
end if;